<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RFID样衣管理系统功能清单</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background-color: #121212;
            margin: 0;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            text-align: center;
            color: #e0e0e0;
            margin-bottom: 30px;
        }
        .table-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            background-color: #1e1e1e;
        }
        th {
            padding: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }
        td {
            padding: 12px;
            text-align: center;
            border: 1px solid #333;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        td:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        .main-header {
            background: linear-gradient(135deg, #7c4dff, #4a148c);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .header-1 {
            background: linear-gradient(135deg, #d50000, #7f0000);
        }
        .header-2 {
            background: linear-gradient(135deg, #2962ff, #0039cb);
        }
        .header-3 {
            background: linear-gradient(135deg, #00c853, #009624);
        }
        .header-4 {
            background: linear-gradient(135deg, #ffab00, #c67c00);
        }
        .item-1 {
            border-left: 3px solid #d50000;
            background-color: rgba(213, 0, 0, 0.1);
        }
        .item-2 {
            border-left: 3px solid #2962ff;
            background-color: rgba(41, 98, 255, 0.1);
        }
        .item-3 {
            border-left: 3px solid #00c853;
            background-color: rgba(0, 200, 83, 0.1);
        }
        .item-4 {
            border-left: 3px solid #ffab00;
            background-color: rgba(255, 171, 0, 0.1);
        }
        
        /* 模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }
        
        .modal-content {
            position: relative;
            background-color: #2d2d2d;
            margin: 5% auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            animation: modalopen 0.5s;
        }
        
        @keyframes modalopen {
            from {opacity: 0; transform: scale(0.8);}
            to {opacity: 1; transform: scale(1);}
        }
        
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-button:hover {
            color: #fff;
        }
        
        .modal-title {
            margin-top: 0;
            color: #fff;
            font-size: 24px;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }
        
        .flowchart {
            width: 100%;
            padding: 20px;
            text-align: center;
        }
        
        .flowchart-step {
            display: inline-block;
            margin: 10px;
            padding: 15px 20px;
            background-color: #3d3d3d;
            border-radius: 8px;
            position: relative;
            cursor: default;
            transition: all 0.3s ease;
        }
        
        .flowchart-step:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 移除悬停提示标签样式 */
        .flowchart-step:hover::after {
            content: none;
        }
        
        .flowchart-step[data-type="forward"]:hover::after {
            content: none;
        }
        
        .flowchart-step[data-type="exception"]:hover::after {
            content: none;
        }
        
        .flowchart-step[data-type="reverse"]:hover::after {
            content: none;
        }
        
        .flowchart-step.editable:hover {
            cursor: grab;
            background-color: #444;
        }
        
        .flowchart-step.editable:hover::after {
            content: none;
        }
        
        .flowchart-step.dragging {
            opacity: 0.7;
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            transform: scale(1.05);
        }
        
        .flowchart-arrow {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            margin: 0 5px;
            color: #888;
            font-size: 24px;
        }
        
        .flowchart-step-1 {
            border-left: 4px solid #d50000;
        }
        
        .flowchart-step-2 {
            border-left: 4px solid #2962ff;
        }
        
        .flowchart-step-3 {
            border-left: 4px solid #00c853;
        }
        
        .flowchart-step-4 {
            border-left: 4px solid #ffab00;
        }
        
        .process-container {
            margin-bottom: 30px;
        }
        
        .process-title {
            font-size: 18px;
            margin: 15px 0;
            color: #ccc;
            text-align: left;
            padding-left: 10px;
            border-left: 3px solid #555;
        }
        
        .reverse-step {
            background-color: #2a2a2a;
            border-style: dashed;
            border-width: 1px;
            border-color: #555;
        }
        
        .reverse-step.flowchart-step-1 {
            border-left: 4px solid rgba(213, 0, 0, 0.6);
        }
        
        .reverse-step.flowchart-step-2 {
            border-left: 4px solid rgba(41, 98, 255, 0.6);
        }
        
        .reverse-step.flowchart-step-3 {
            border-left: 4px solid rgba(0, 200, 83, 0.6);
        }
        
        .reverse-step.flowchart-step-4 {
            border-left: 4px solid rgba(255, 171, 0, 0.6);
        }
        
        .flowchart-reverse-arrow {
            color: #666;
            transform: rotate(180deg);
        }
        
        /* 异常流程样式 */
        .exception-flow {
            margin-top: 15px;
            padding: 10px;
            border: 1px dashed #444;
            border-radius: 8px;
            background-color: rgba(80, 0, 0, 0.2);
            position: relative;
        }
        
        .exception-title {
            position: absolute;
            top: -10px;
            left: 20px;
            padding: 0 10px;
            background-color: #2d2d2d;
            color: #ff6b6b;
            font-size: 14px;
        }
        
        .exception-step {
            background-color: #3a2a2a;
            border-left: 4px solid #ff6b6b;
        }
        
        .exception-arrow {
            color: #ff6b6b;
            font-size: 18px;
        }
        
        .flow-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .main-flow {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        /* 编辑模式样式 */
        .edit-mode-controls {
            display: block;
            margin: 15px 0;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
            text-align: center;
        }
        
        .edit-mode-active .edit-mode-controls {
            display: block;
        }
        
        .edit-btn, .add-node-btn, .save-btn {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 8px 12px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .edit-btn:hover, .add-node-btn:hover, .save-btn:hover {
            background-color: #555;
        }
        
        .edit-btn.active {
            background-color: #7c4dff;
        }
        
        .flowchart-step.editable {
            cursor: grab;
        }
        
        .flowchart-step.dragging {
            opacity: 0.7;
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .drag-placeholder {
            display: inline-block;
            margin: 10px;
            padding: 15px 20px;
            background-color: #555;
            border-radius: 8px;
            border: 2px dashed #888;
            opacity: 0.6;
        }
        
        .node-edit-input {
            background-color: transparent;
            border: none;
            color: #fff;
            font-size: inherit;
            font-family: inherit;
            width: 100%;
            text-align: center;
            padding: 0;
            margin: 0;
            outline: none;
        }
        
        .node-actions {
            display: none;
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            border-radius: 20px;
            padding: 5px 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 100;
            white-space: nowrap;
        }
        
        .node-action-btn {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            margin: 0 3px;
            border-radius: 15px;
            cursor: pointer;
            color: #fff;
            font-size: 16px;
        }
        
        .action-save {
            background-color: #00c853;
        }
        
        .action-cancel {
            background-color: #607d8b;
        }
        
        .action-delete {
            background-color: #f44336;
        }
        
        .flowchart-step.editing {
            border: 2px solid #7c4dff;
            background-color: #333;
        }
        
        .edit-node-form {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
            display: none;
        }
        
        .edit-node-form input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background-color: #444;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
        }
        
        .edit-node-form button {
            background-color: #7c4dff;
            color: #fff;
            border: none;
            padding: 8px 12px;
            margin-right: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .edit-node-form button.delete-btn {
            background-color: #d50000;
        }
        
        .add-node-btn {
            background-color: #00c853;
        }
        
        .save-btn {
            background-color: #2962ff;
        }
        
        .delete-node-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background-color: #d50000;
            color: white;
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            cursor: pointer;
            z-index: 10;
        }
        
        .edit-mode-active .flowchart-step:hover .delete-node-btn {
            display: flex;
        }
    </style>
</head>
<body>
    <h1>RFID样衣管理系统功能表格</h1>
    
    <div class="table-container">
        <div class="main-header">RFID样衣管理系统</div>
        
        <table>
            <thead>
                <tr>
                    <th class="header-1">样衣入库</th>
                    <th class="header-2">样衣出库</th>
                    <th class="header-3">样衣盘点</th>
                    <th class="header-4">系统设置</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="item-1" onclick="openModal('RFID标签绑定', 'rfid-binding')">RFID标签绑定</td>
                    <td class="item-2" onclick="openModal('出库申请审批', 'checkout-approval')">出库申请审批</td>
                    <td class="item-3" onclick="openModal('实时库存查询', 'inventory-query')">实时库存查询</td>
                    <td class="item-4" onclick="openModal('用户权限管理', 'user-permission')">用户权限管理</td>
                </tr>
                <tr>
                    <td class="item-1" onclick="openModal('样衣信息录入', 'sample-info')">样衣信息录入</td>
                    <td class="item-2" onclick="openModal('样衣借用登记', 'sample-borrowing')">样衣借用登记</td>
                    <td class="item-3" onclick="openModal('盘点计划制定', 'inventory-plan')">盘点计划制定</td>
                    <td class="item-4" onclick="openModal('基础数据配置', 'basic-config')">基础数据配置</td>
                </tr>
                <tr>
                    <td class="item-1" onclick="openModal('入库批量扫描', 'batch-scanning')">入库批量扫描</td>
                    <td class="item-2" onclick="openModal('出库扫描确认', 'checkout-scan')">出库扫描确认</td>
                    <td class="item-3" onclick="openModal('盘点差异分析', 'inventory-analysis')">盘点差异分析</td>
                    <td class="item-4" onclick="openModal('RFID设备管理', 'device-management')">RFID设备管理</td>
                </tr>
                <tr>
                    <td class="item-1" onclick="openModal('入库数据汇总', 'data-summary')">入库数据汇总</td>
                    <td class="item-2" onclick="openModal('归还时间提醒', 'return-reminder')">归还时间提醒</td>
                    <td class="item-3" onclick="openModal('盘点报表生成', 'inventory-report')">盘点报表生成</td>
                    <td class="item-4" onclick="openModal('数据备份恢复', 'data-backup')">数据备份恢复</td>
                </tr>
            </tbody>
        </table>
    </div>
    
    <!-- 模态框 -->
    <div id="functionModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle" class="modal-title"></h2>
            
            <div class="edit-mode-controls">
                <button class="edit-btn" onclick="toggleEditMode()">编辑模式</button>
                <button class="add-node-btn" onclick="showAddNodeForm('forward')" id="addForwardBtn" style="display:none;">添加正向流程节点</button>
                <button class="add-node-btn" onclick="showAddNodeForm('exception')" id="addExceptionBtn" style="display:none;">添加异常流程节点</button>
                <button class="add-node-btn" onclick="showAddNodeForm('reverse')" id="addReverseBtn" style="display:none;">添加逆向流程节点</button>
                <button class="save-btn" onclick="saveFlowchartChanges()" id="saveChangesBtn" style="display:none;">保存更改</button>
            </div>
            
            <div id="editNodeForm" class="edit-node-form">
                <input type="text" id="nodeContent" placeholder="节点内容">
                <input type="hidden" id="nodeType">
                <input type="hidden" id="nodeIndex">
                <button onclick="saveNodeEdit()">保存</button>
                <button onclick="cancelNodeEdit()">取消</button>
                <button class="delete-btn" onclick="deleteNode()">删除节点</button>
            </div>
            
            <div id="addNodeForm" class="edit-node-form">
                <input type="text" id="newNodeContent" placeholder="新节点内容">
                <input type="hidden" id="newNodeType">
                <button onclick="addNewNode()">添加</button>
                <button onclick="cancelAddNode()">取消</button>
            </div>
            
            <div id="flowchartContainer" class="flowchart"></div>
        </div>
    </div>
    
    <script>
        // 获取模态框元素
        const modal = document.getElementById("functionModal");
        const modalTitle = document.getElementById("modalTitle");
        const flowchartContainer = document.getElementById("flowchartContainer");
        const editNodeForm = document.getElementById("editNodeForm");
        const addNodeForm = document.getElementById("addNodeForm");
        
        // 当前编辑的功能ID
        let currentFunctionId = "";
        // 编辑模式状态
        let editModeActive = false;
        // 当前流程图数据
        let currentFlowchartData = {};
        
        // 当前拖拽元素
        let dragNode = null;
        let dragNodeData = { type: "", index: -1 };
        let dragStartPos = { x: 0, y: 0 };
        let dragPlaceholder = null;
        // 是否有未保存的节点顺序变更
        let hasUnsavedChanges = false;
        
        // 打开模态框
        function openModal(title, functionId) {
            modalTitle.textContent = title + " - 功能流程图";
            currentFunctionId = functionId;
            
            // 获取流程图数据
            currentFlowchartData = getFlowSteps(functionId);
            
            // 根据不同功能ID生成对应的流程图
            generateFlowchart(functionId);
            
            // 重置编辑模式
            editModeActive = false;
            hasUnsavedChanges = false;
            document.getElementById("addForwardBtn").style.display = "none";
            document.getElementById("addExceptionBtn").style.display = "none";
            document.getElementById("addReverseBtn").style.display = "none";
            document.getElementById("saveChangesBtn").style.display = "none";
            
            modal.style.display = "block";
        }
        
        // 关闭模态框
        function closeModal() {
            if (hasUnsavedChanges) {
                if (confirm("有未保存的变更，确定要关闭吗？")) {
                    modal.style.display = "none";
                    editNodeForm.style.display = "none";
                    addNodeForm.style.display = "none";
                }
            } else {
                modal.style.display = "none";
                editNodeForm.style.display = "none";
                addNodeForm.style.display = "none";
            }
        }
        
        // 点击模态框外部关闭
        window.onclick = function(event) {
            if (event.target == modal) {
                closeModal();
            }
        }
        
        // 生成流程图
        function generateFlowchart(functionId) {
            let flowchartHTML = "";
            let stepClass = "";
            
            // 根据功能ID确定流程图样式类
            if (functionId.startsWith("rfid-") || functionId.startsWith("sample-") || 
                functionId.startsWith("batch-") || functionId.startsWith("data-summary")) {
                stepClass = "flowchart-step-1";
            } else if (functionId.startsWith("checkout-") || functionId.startsWith("return-")) {
                stepClass = "flowchart-step-2";
            } else if (functionId.startsWith("inventory-")) {
                stepClass = "flowchart-step-3";
            } else {
                stepClass = "flowchart-step-4";
            }
            
            // 获取正向、异常和逆向流程
            const { forwardSteps, exceptionSteps, reverseSteps } = currentFlowchartData;
            
            // 添加正向流程
            flowchartHTML += `<div class="process-container">`;
            flowchartHTML += `<div class="process-title">正向流程</div>`;
            
            // 添加正向流程容器
            flowchartHTML += `<div class="flow-wrapper">`;
            
            // 构建正向主流程
            flowchartHTML += `<div class="main-flow" data-flow-type="forward">`;
            for (let i = 0; i < forwardSteps.length; i++) {
                flowchartHTML += `<div class="flowchart-step ${stepClass}" data-type="forward" data-index="${i}" data-description="步骤 ${i+1}: ${forwardSteps[i]}" draggable="false" onclick="handleNodeClick(this)">${forwardSteps[i]}</div>`;
                
                // 除了最后一步，其他步骤后面都加箭头
                if (i < forwardSteps.length - 1) {
                    flowchartHTML += `<div class="flowchart-arrow">→</div>`;
                }
            }
            flowchartHTML += `</div>`;
            
            // 如果有异常流程，则添加异常流程
            if (exceptionSteps && exceptionSteps.length > 0) {
                flowchartHTML += `<div class="exception-flow">`;
                flowchartHTML += `<div class="exception-title">异常流程</div>`;
                
                flowchartHTML += `<div class="main-flow" data-flow-type="exception">`;
                for (let i = 0; i < exceptionSteps.length; i++) {
                    flowchartHTML += `<div class="flowchart-step exception-step" data-type="exception" data-index="${i}" data-description="异常处理 ${i+1}: ${exceptionSteps[i]}" draggable="false" onclick="handleNodeClick(this)">${exceptionSteps[i]}</div>`;
                    
                    if (i < exceptionSteps.length - 1) {
                        flowchartHTML += `<div class="flowchart-arrow exception-arrow">→</div>`;
                    }
                }
                flowchartHTML += `</div>`;
                
                flowchartHTML += `</div>`;
            }
            
            flowchartHTML += `</div>`; // 关闭flow-wrapper
            flowchartHTML += `</div>`; // 关闭process-container
            
            // 添加逆向流程
            if (reverseSteps && reverseSteps.length > 0) {
                flowchartHTML += `<div class="process-container">`;
                flowchartHTML += `<div class="process-title">逆向流程</div>`;
                
                // 构建逆向流程图HTML
                flowchartHTML += `<div class="main-flow" data-flow-type="reverse">`;
                for (let i = 0; i < reverseSteps.length; i++) {
                    flowchartHTML += `<div class="flowchart-step reverse-step ${stepClass}" data-type="reverse" data-index="${i}" data-description="逆向处理 ${i+1}: ${reverseSteps[i]}" draggable="false" onclick="handleNodeClick(this)">${reverseSteps[i]}</div>`;
                    
                    // 除了最后一步，其他步骤后面都加箭头
                    if (i < reverseSteps.length - 1) {
                        flowchartHTML += `<div class="flowchart-arrow flowchart-reverse-arrow">→</div>`;
                    }
                }
                flowchartHTML += `</div>`;
                flowchartHTML += `</div>`;
            }
            
            flowchartContainer.innerHTML = flowchartHTML;
            
            // 只有在编辑模式下才初始化拖拽
            if (editModeActive) {
                initDragForNodes();
            }
        }
        
        // 处理节点点击事件
        function handleNodeClick(node) {
            // 如果点击的是删除按钮，不处理
            if (event.target.classList.contains("delete-node-btn")) return;
            
            // 保存点击的坐标，用于后续计算光标位置
            const clickX = event.clientX;
            
            // 如果不是编辑模式，则自动启用编辑模式
            if (!editModeActive) {
                toggleEditMode();
                setTimeout(() => {
                    startEditingNode(node, clickX);
                }, 100);
            } else {
                // 如果节点正在被拖拽中，不处理点击事件
                if (node.classList.contains("dragging")) return;
                
                // 检查是否是拖拽操作的开始
                const isDragAttempt = node.getAttribute("draggable") === "true" && !node.classList.contains("editing");
                
                // 如果是编辑模式且节点允许拖拽，需要区分拖拽和编辑操作
                if (isDragAttempt) {
                    // 使用延迟来区分点击和拖拽意图
                    const clickTime = new Date().getTime();
                    node.dataset.clickTime = clickTime;
                    
                    setTimeout(() => {
                        // 如果这个时间戳还存在，说明用户没有开始拖拽，是想编辑
                        if (node.dataset.clickTime == clickTime) {
                            delete node.dataset.clickTime;
                            startEditingNode(node, clickX);
                        }
                    }, 200); // 200ms的延迟用于区分点击和拖拽
                } else {
                    // 如果不是拖拽意图，直接进入编辑模式
                    startEditingNode(node, clickX);
                }
            }
        }
        
        // 开始编辑节点
        function startEditingNode(node, clickX) {
            // 如果正在拖拽，不允许编辑
            if (dragNode !== null) return;
            
            // 清除之前正在编辑的节点
            const editingNodes = document.querySelectorAll(".flowchart-step.editing");
            editingNodes.forEach(editingNode => {
                stopEditingNode(editingNode, true);
            });
            
            // 标记当前节点为编辑状态
            node.classList.add("editing");
            
            // 获取干净的文本内容
            const cloneNode = node.cloneNode(true);
            const delBtn = cloneNode.querySelector(".delete-node-btn");
            if (delBtn) {
                cloneNode.removeChild(delBtn);
            }
            const nodeContent = cloneNode.textContent;
            
            // 保存原始内容到节点的data属性
            node.dataset.originalContent = nodeContent;
            
            // 清空节点内容
            node.innerHTML = '';
            
            // 创建输入框
            const input = document.createElement("input");
            input.type = "text";
            input.className = "node-edit-input";
            input.value = nodeContent;
            
            // 处理点击事件，允许用户在已经在编辑状态的输入框中点击定位光标
            input.addEventListener("click", function(e) {
                // 只有在没有选中文本的情况下才处理光标定位
                // 如果用户正在选择文本（按下Shift键或使用鼠标拖动选择），则不干预
                if (!window.getSelection().toString() && !e.shiftKey) {
                    e.stopPropagation(); // 阻止事件冒泡，避免触发handleNodeClick
                    
                    // 获取点击相对于输入框的位置
                    const inputRect = input.getBoundingClientRect();
                    const clickPosition = e.clientX - inputRect.left;
                    
                    // 计算光标位置（使用字符平均宽度估算）
                    const averageCharWidth = inputRect.width / input.value.length;
                    const cursorPosition = Math.round(clickPosition / averageCharWidth);
                    
                    // 设置光标位置，确保在有效范围内
                    const position = Math.min(Math.max(0, cursorPosition), input.value.length);
                    input.setSelectionRange(position, position);
                } else {
                    // 如果用户正在选择文本，只阻止冒泡避免触发其他事件
                    e.stopPropagation();
                }
            });
            
            // 添加快捷键支持，如Ctrl+A全选
            input.addEventListener("keydown", function(e) {
                if (e.key === "Enter") {
                    saveNodeContent(node);
                } else if (e.key === "Escape") {
                    cancelNodeEdit(node);
                } else if (e.key === "a" && (e.ctrlKey || e.metaKey)) {
                    // Ctrl+A 或 Command+A (Mac) 全选
                    e.preventDefault();
                    input.select();
                }
            });
            
            node.appendChild(input);
            
            // 添加操作按钮
            const actions = document.createElement("div");
            actions.className = "node-actions";
            
            const saveBtn = document.createElement("span");
            saveBtn.className = "node-action-btn action-save";
            saveBtn.innerHTML = "✓";
            saveBtn.title = "保存";
            saveBtn.onclick = function(e) {
                e.stopPropagation();
                saveNodeContent(node);
            };
            
            const cancelBtn = document.createElement("span");
            cancelBtn.className = "node-action-btn action-cancel";
            cancelBtn.innerHTML = "✕";
            cancelBtn.title = "取消";
            cancelBtn.onclick = function(e) {
                e.stopPropagation();
                cancelNodeEdit(node);
            };
            
            actions.appendChild(saveBtn);
            actions.appendChild(cancelBtn);
            node.appendChild(actions);
            
            // 聚焦输入框
            setTimeout(() => {
                input.focus();
                
                // 如果有点击坐标，设置光标位置
                if (clickX) {
                    // 获取节点位置和宽度信息
                    const rect = node.getBoundingClientRect();
                    const nodeStartX = rect.left;
                    const nodeWidth = rect.width;
                    
                    // 计算点击位置在节点中的比例
                    const ratio = (clickX - nodeStartX) / nodeWidth;
                    // 根据比例计算光标应该在文本中的位置
                    const cursorPosition = Math.round(nodeContent.length * ratio);
                    // 设置光标位置
                    input.setSelectionRange(cursorPosition, cursorPosition);
                }
            }, 10);
            
            // 禁用节点拖拽
            node.setAttribute("draggable", "false");
            
            // 添加点击其他区域自动退出编辑的事件处理
            setTimeout(() => {
                document.addEventListener('click', handleClickOutside);
            }, 100);
        }
        
        // 停止编辑节点
        function stopEditingNode(node, discard = false) {
            node.classList.remove("editing");
            
            const input = node.querySelector(".node-edit-input");
            const actions = node.querySelector(".node-actions");
            
            if (input && actions) {
                if (!discard) {
                    node.textContent = input.value;
                } else {
                    node.textContent = node.dataset.originalContent || "";
                }
                
                // 如果在编辑模式，重新添加删除按钮并恢复拖拽功能
                if (editModeActive) {
                    addDeleteButton(node);
                    node.setAttribute("draggable", "true");
                }
            }
            
            // 清除点击时间戳
            delete node.dataset.clickTime;
            
            // 移除点击其他区域自动退出编辑的事件处理
            document.removeEventListener('click', handleClickOutside);
        }
        
        // 处理点击编辑区域外部
        function handleClickOutside(event) {
            const editingNode = document.querySelector(".flowchart-step.editing");
            if (!editingNode) {
                document.removeEventListener('click', handleClickOutside);
                return;
            }
            
            // 检查点击是否在编辑节点外部
            if (editingNode && !editingNode.contains(event.target) && 
                !event.target.classList.contains('node-action-btn')) {
                
                const input = editingNode.querySelector(".node-edit-input");
                const originalContent = editingNode.dataset.originalContent || "";
                
                // 检查内容是否有变化
                if (input && input.value !== originalContent) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    // 询问用户是否保存变更
                    if (confirm("当前节点有变化，是否采用？")) {
                        saveNodeContent(editingNode);
                    } else {
                        cancelNodeEdit(editingNode);
                    }
                } else {
                    // 内容没有变化，直接退出编辑
                    cancelNodeEdit(editingNode);
                }
                
                document.removeEventListener('click', handleClickOutside);
            }
        }
        
        // 保存节点内容
        function saveNodeContent(node) {
            const input = node.querySelector(".node-edit-input");
            if (input && input.value.trim() !== "") {
                const nodeType = node.dataset.type;
                const nodeIndex = parseInt(node.dataset.index);
                
                // 更新流程图数据
                currentFlowchartData[nodeType + "Steps"][nodeIndex] = input.value;
                
                stopEditingNode(node);
            } else {
                alert("节点内容不能为空");
            }
        }
        
        // 取消节点编辑
        function cancelNodeEdit(node) {
            stopEditingNode(node, true);
        }
        
        // 删除节点内容
        function deleteNodeContent(node) {
            const nodeType = node.dataset.type;
            const nodeIndex = parseInt(node.dataset.index);
            
            // 确认删除
            if (confirm("确定要删除这个节点吗？")) {
                deleteNodeDirectly(nodeType, nodeIndex);
            }
        }
        
        // 添加删除按钮到节点
        function addDeleteButton(node) {
            if (!node.querySelector(".delete-node-btn")) {
                const nodeDeleBtn = document.createElement("div");
                nodeDeleBtn.className = "delete-node-btn";
                nodeDeleBtn.innerHTML = "×";
                nodeDeleBtn.onclick = function(e) {
                    e.stopPropagation();
                    const nodeType = node.dataset.type;
                    const nodeIndex = parseInt(node.dataset.index);
                    deleteNodeDirectly(nodeType, nodeIndex);
                };
                node.appendChild(nodeDeleBtn);
            }
        }
        
        // 直接删除节点
        function deleteNodeDirectly(nodeType, nodeIndex) {
            // 从流程图数据中删除节点
            currentFlowchartData[nodeType + "Steps"].splice(nodeIndex, 1);
            
            // 如果删除后流程为空，创建一个默认节点
            if (currentFlowchartData[nodeType + "Steps"].length === 0) {
                currentFlowchartData[nodeType + "Steps"].push("步骤1");
            }
            
            // 只更新被修改的流程部分，不重新生成整个流程图
            updateFlowchartWithoutReinitialize(nodeType);
            
            // 标记有未保存的变更
            hasUnsavedChanges = true;
            document.getElementById("saveChangesBtn").style.backgroundColor = "#ff4081";
            document.getElementById("saveChangesBtn").innerHTML = "保存变更*";
        }
        
        // 切换编辑模式
        function toggleEditMode() {
            editModeActive = !editModeActive;
            const editBtn = document.querySelector(".edit-btn");
            
            if (editModeActive) {
                editBtn.classList.add("active");
                flowchartContainer.classList.add("edit-mode-active");
                document.getElementById("addForwardBtn").style.display = "inline-block";
                document.getElementById("addExceptionBtn").style.display = "inline-block";
                document.getElementById("addReverseBtn").style.display = "inline-block";
                document.getElementById("saveChangesBtn").style.display = "inline-block";
                
                // 隐藏编辑表单
                editNodeForm.style.display = "none";
                
                // 为所有步骤添加可编辑标记并启用拖拽
                const steps = flowchartContainer.querySelectorAll(".flowchart-step");
                steps.forEach((step, index) => {
                    step.classList.add("editable");
                    step.setAttribute("draggable", "true");
                    
                    // 添加删除按钮
                    addDeleteButton(step);
                });
                
                // 初始化拖拽功能
                initDragForNodes();
            } else {
                editBtn.classList.remove("active");
                flowchartContainer.classList.remove("edit-mode-active");
                document.getElementById("addForwardBtn").style.display = "none";
                document.getElementById("addExceptionBtn").style.display = "none";
                document.getElementById("addReverseBtn").style.display = "none";
                document.getElementById("saveChangesBtn").style.display = "none";
                
                // 停止所有正在编辑的节点
                const editingNodes = document.querySelectorAll(".flowchart-step.editing");
                editingNodes.forEach(node => {
                    stopEditingNode(node, true);
                });
                
                // 移除可编辑标记并禁用拖拽
                const steps = flowchartContainer.querySelectorAll(".flowchart-step");
                steps.forEach(step => {
                    step.classList.remove("editable");
                    step.classList.remove("dragging");
                    step.setAttribute("draggable", "false");
                    
                    // 移除删除按钮
                    const nodeDeleBtn = step.querySelector(".delete-node-btn");
                    if (nodeDeleBtn) {
                        step.removeChild(nodeDeleBtn);
                    }
                });
                
                // 移除拖拽相关事件
                removeDragEvents();
                
                editNodeForm.style.display = "none";
                addNodeForm.style.display = "none";
            }
        }
        
        // 显示添加节点表单
        function showAddNodeForm(type) {
            document.getElementById("newNodeContent").value = "";
            document.getElementById("newNodeType").value = type;
            addNodeForm.style.display = "block";
            editNodeForm.style.display = "none";
        }
        
        // 添加新节点
        function addNewNode() {
            const nodeContent = document.getElementById("newNodeContent").value;
            const nodeType = document.getElementById("newNodeType").value;
            
            if (nodeContent.trim() === "") {
                alert("节点内容不能为空");
                return;
            }
            
            // 添加新节点到流程图数据
            currentFlowchartData[nodeType + "Steps"].push(nodeContent);
            
            // 重新生成流程图
            generateFlowchart(currentFunctionId);
            
            // 恢复编辑模式
            toggleEditMode();
            toggleEditMode();
            
            addNodeForm.style.display = "none";
        }
        
        // 取消添加节点
        function cancelAddNode() {
            addNodeForm.style.display = "none";
        }
        
        // 保存流程图更改
        function saveFlowchartChanges() {
            // 在实际应用中，这里应该发送数据到服务器保存
            // 这里我们只是简单地将更改保存到本地会话存储
            localStorage.setItem(`flowchart_${currentFunctionId}`, JSON.stringify(currentFlowchartData));
            alert("流程图更改已保存！");
            
            // 重置未保存变更标记
            hasUnsavedChanges = false;
            document.getElementById("saveChangesBtn").style.backgroundColor = "";
            document.getElementById("saveChangesBtn").innerHTML = "保存更改";
            
            // 保持编辑模式
            if (!editModeActive) {
                toggleEditMode();
            }
        }
        
        // 获取不同功能的流程步骤
        function getFlowSteps(functionId) {
            // 先尝试从本地存储中获取
            const savedData = localStorage.getItem(`flowchart_${functionId}`);
            if (savedData) {
                return JSON.parse(savedData);
            }
            
            const flowStepsMap = {
                // 样衣入库相关流程
                "rfid-binding": {
                    forwardSteps: ["准备RFID标签", "扫描样衣条码", "绑定标签与样衣信息", "确认绑定成功"],
                    exceptionSteps: ["标签识别失败", "尝试重新读取", "更换标签", "手动录入"],
                    reverseSteps: ["选择已绑定样衣", "解除标签绑定", "回收RFID标签", "更新绑定状态"]
                },
                "sample-info": {
                    forwardSteps: ["录入基本信息", "填写样衣详情", "上传样衣图片", "保存样衣信息"],
                    exceptionSteps: ["数据格式错误", "信息校验失败", "重新填写", "临时保存"],
                    reverseSteps: ["查询样衣记录", "编辑样衣信息", "修改或删除记录", "确认信息更新"]
                },
                "batch-scanning": {
                    forwardSteps: ["放置样衣于扫描区", "启动批量扫描", "验证扫描结果", "确认入库"],
                    exceptionSteps: ["部分样衣未识别", "调整样衣位置", "重新扫描", "标记问题样衣"],
                    reverseSteps: ["选择入库批次", "标记扫描错误", "移除错误样衣", "重新扫描确认"]
                },
                "data-summary": {
                    forwardSteps: ["筛选入库数据", "统计分类汇总", "生成入库报表", "数据导出备份"],
                    exceptionSteps: ["数据不完整", "检查缺失数据", "补充数据", "重新汇总"],
                    reverseSteps: ["选择数据周期", "查看历史报表", "撤回错误报表", "重新生成报表"]
                },
                
                // 样衣出库相关流程
                "checkout-approval": {
                    forwardSteps: ["提交出库申请", "主管审批", "审批结果通知", "准备出库"],
                    exceptionSteps: ["申请信息不完整", "申请被拒绝", "修改申请内容", "重新提交"],
                    reverseSteps: ["申请撤回审批", "取消出库申请", "更新申请状态", "通知相关人员"]
                },
                "sample-borrowing": {
                    forwardSteps: ["填写借用信息", "选择借用人", "设置归还日期", "确认借出"],
                    exceptionSteps: ["借用人信息有误", "归还日期冲突", "样衣状态异常", "调整借用信息"],
                    reverseSteps: ["取消借用登记", "恢复样衣状态", "记录取消原因", "更新借用记录"]
                },
                "checkout-scan": {
                    forwardSteps: ["扫描样衣标签", "核对出库信息", "确认出库操作", "更新库存状态"],
                    exceptionSteps: ["标签识别失败", "出库信息不匹配", "样衣状态异常", "手动处理"],
                    reverseSteps: ["扫描误出样衣", "标记错误出库", "恢复库存状态", "记录异常情况"]
                },
                "return-reminder": {
                    forwardSteps: ["检查逾期样衣", "发送归还提醒", "跟踪归还状态", "归还确认"],
                    exceptionSteps: ["联系人信息过期", "无法联系借用人", "多次提醒无回应", "升级处理"],
                    reverseSteps: ["撤回错误提醒", "延长借用期限", "更新归还日期", "取消归还提醒"]
                },
                
                // 样衣盘点相关流程
                "inventory-query": {
                    forwardSteps: ["设置查询条件", "执行库存查询", "显示查询结果", "导出库存数据"],
                    exceptionSteps: ["查询超时", "结果数据量过大", "重新设置条件", "分批查询"],
                    reverseSteps: ["修改查询条件", "重新查询数据", "标记异常数据", "保存查询记录"]
                },
                "inventory-plan": {
                    forwardSteps: ["制定盘点周期", "选择盘点范围", "分配盘点任务", "发布盘点计划"],
                    exceptionSteps: ["任务分配冲突", "范围设置不合理", "人员不足", "调整计划"],
                    reverseSteps: ["撤回盘点计划", "调整盘点范围", "重新分配任务", "更新计划状态"]
                },
                "inventory-analysis": {
                    forwardSteps: ["比对账面数据", "分析差异原因", "记录差异结果", "提出处理建议"],
                    exceptionSteps: ["差异数据异常", "原因无法确定", "需要现场核查", "暂缓分析"],
                    reverseSteps: ["重新核对数据", "修正分析结果", "更新差异记录", "调整处理方案"]
                },
                "inventory-report": {
                    forwardSteps: ["汇总盘点结果", "生成盘点报表", "报表审核确认", "分发报表"],
                    exceptionSteps: ["数据不完整", "报表格式错误", "审核不通过", "重新生成"],
                    reverseSteps: ["撤回错误报表", "修正报表数据", "重新生成报表", "更新报表版本"]
                },
                
                // 系统设置相关流程
                "user-permission": {
                    forwardSteps: ["用户分组管理", "角色权限设置", "功能访问控制", "权限变更审计"],
                    exceptionSteps: ["用户分组冲突", "权限设置矛盾", "系统拒绝变更", "降级处理"],
                    reverseSteps: ["回滚权限变更", "恢复默认权限", "记录回滚原因", "通知相关用户"]
                },
                "basic-config": {
                    forwardSteps: ["品类信息设置", "部门信息配置", "标签参数设置", "系统参数调整"],
                    exceptionSteps: ["配置格式错误", "参数值超出范围", "影响已有数据", "调整配置"],
                    reverseSteps: ["备份当前配置", "恢复历史配置", "回滚参数设置", "验证配置有效性"]
                },
                "device-management": {
                    forwardSteps: ["设备注册管理", "设备状态监控", "设备参数配置", "设备固件更新"],
                    exceptionSteps: ["设备连接失败", "参数设置被拒", "固件更新失败", "恢复默认设置"],
                    reverseSteps: ["设备固件回滚", "重置设备配置", "解除设备注册", "恢复出厂设置"]
                },
                "data-backup": {
                    forwardSteps: ["设置备份计划", "执行数据备份", "备份文件管理", "数据恢复操作"],
                    exceptionSteps: ["备份空间不足", "备份过程中断", "文件损坏", "启用应急备份"],
                    reverseSteps: ["取消备份任务", "删除备份文件", "中断恢复操作", "回滚已恢复数据"]
                }
            };
            
            return flowStepsMap[functionId] || {
                forwardSteps: ["步骤1", "步骤2", "步骤3", "步骤4"],
                exceptionSteps: ["异常情况1", "处理方法1", "异常情况2", "处理方法2"],
                reverseSteps: ["逆向步骤1", "逆向步骤2", "逆向步骤3", "逆向步骤4"]
            };
        }
        
        // 初始化拖拽功能
        function initDragForNodes() {
            const flowNodes = document.querySelectorAll(".flowchart-step.editable");
            const flowContainers = document.querySelectorAll(".main-flow");
            
            // 为每个节点添加拖拽事件
            flowNodes.forEach(node => {
                node.addEventListener("dragstart", handleDragStart);
                node.addEventListener("dragend", handleDragEnd);
            });
            
            // 为每个流程容器添加拖拽相关事件
            flowContainers.forEach(container => {
                container.addEventListener("dragover", handleDragOver);
                container.addEventListener("dragenter", handleDragEnter);
                container.addEventListener("dragleave", handleDragLeave);
                container.addEventListener("drop", handleDrop);
            });
        }
        
        // 移除拖拽相关事件
        function removeDragEvents() {
            const flowNodes = document.querySelectorAll(".flowchart-step");
            const flowContainers = document.querySelectorAll(".main-flow");
            
            // 移除每个节点的拖拽事件
            flowNodes.forEach(node => {
                node.removeEventListener("dragstart", handleDragStart);
                node.removeEventListener("dragend", handleDragEnd);
            });
            
            // 移除每个流程容器的拖拽相关事件
            flowContainers.forEach(container => {
                container.removeEventListener("dragover", handleDragOver);
                container.removeEventListener("dragenter", handleDragEnter);
                container.removeEventListener("dragleave", handleDragLeave);
                container.removeEventListener("drop", handleDrop);
            });
        }
        
        // 处理拖拽开始事件
        function handleDragStart(e) {
            // 如果节点正在编辑中，取消拖拽
            if (this.classList.contains("editing")) {
                e.preventDefault();
                return false;
            }
            
            // 清除点击时间戳，表明这是拖拽而非点击
            delete this.dataset.clickTime;
            
            // 标记当前拖拽节点
            this.classList.add("dragging");
            dragNode = this;
            dragNodeData.type = this.getAttribute("data-type");
            dragNodeData.index = parseInt(this.getAttribute("data-index"));
            
            // 记录鼠标位置，用于计算拖拽偏移
            dragStartPos.x = e.clientX;
            dragStartPos.y = e.clientY;
            
            // 设置拖拽效果和数据
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", JSON.stringify(dragNodeData));
            
            // 创建并显示占位符
            createDragPlaceholder();
            
            // 延迟设置透明度，避免拖拽图像透明
            setTimeout(() => {
                this.style.opacity = "0.4";
            }, 0);
            
            return true;
        }
        
        // 处理拖拽结束事件
        function handleDragEnd(e) {
            // 移除拖拽样式
            this.classList.remove("dragging");
            this.style.opacity = "";
            
            // 移除所有占位符
            removeDragPlaceholder();
            
            // 清空拖拽状态
            dragNode = null;
            dragNodeData = { type: "", index: -1 };
        }
        
        // 处理拖拽经过事件
        function handleDragOver(e) {
            // 允许放置
            if (e.preventDefault) {
                e.preventDefault();
            }
            
            e.dataTransfer.dropEffect = "move";
            return false;
        }
        
        // 处理拖拽进入事件
        function handleDragEnter(e) {
            e.preventDefault();
            
            // 只在同类型流程容器上高亮
            const containerType = this.getAttribute("data-flow-type");
            if (containerType === dragNodeData.type) {
                this.classList.add("drag-over");
            }
        }
        
        // 处理拖拽离开事件
        function handleDragLeave(e) {
            this.classList.remove("drag-over");
        }
        
        // 处理拖拽放置事件
        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            
            // 移除高亮样式
            this.classList.remove("drag-over");
            
            // 获取拖拽数据
            const data = JSON.parse(e.dataTransfer.getData("text/plain"));
            const sourceType = data.type;
            const sourceIndex = data.index;
            
            // 获取目标容器类型
            const targetType = this.getAttribute("data-flow-type");
            
            // 如果不是同类型容器，不允许放置
            if (sourceType !== targetType) {
                return false;
            }
            
            // 计算放置位置
            const targetIndex = calculateDropIndex(e, this);
            
            // 如果位置相同，不做任何处理
            if (sourceIndex === targetIndex) {
                return false;
            }
            
            // 更新流程图数据
            moveNode(sourceType, sourceIndex, targetIndex);
            
            // 标记有未保存的变更
            hasUnsavedChanges = true;
            document.getElementById("saveChangesBtn").style.backgroundColor = "#ff4081";
            document.getElementById("saveChangesBtn").innerHTML = "保存变更*";
            
            return false;
        }
        
        // 创建拖拽占位符
        function createDragPlaceholder() {
            dragPlaceholder = document.createElement("div");
            dragPlaceholder.className = "drag-placeholder";
            dragPlaceholder.textContent = dragNode.textContent;
        }
        
        // 移除拖拽占位符
        function removeDragPlaceholder() {
            if (dragPlaceholder && dragPlaceholder.parentNode) {
                dragPlaceholder.parentNode.removeChild(dragPlaceholder);
            }
            dragPlaceholder = null;
        }
        
        // 计算放置索引
        function calculateDropIndex(e, container) {
            // 获取容器中所有节点和箭头
            const nodes = Array.from(container.querySelectorAll(".flowchart-step"));
            const nodeType = dragNodeData.type;
            
            // 获取鼠标在容器中的位置
            const containerRect = container.getBoundingClientRect();
            const mouseX = e.clientX - containerRect.left;
            
            // 根据鼠标位置计算最近的节点索引
            let closestIndex = 0;
            let closestDistance = Infinity;
            
            nodes.forEach((node, index) => {
                const nodeRect = node.getBoundingClientRect();
                const nodeCenter = nodeRect.left + nodeRect.width / 2 - containerRect.left;
                const distance = Math.abs(mouseX - nodeCenter);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestIndex = index;
                    
                    // 如果鼠标在节点右侧，放置在节点后面
                    if (mouseX > nodeCenter) {
                        closestIndex = index + 1;
                    }
                }
            });
            
            // 考虑源节点索引的影响
            if (dragNodeData.index < closestIndex) {
                closestIndex--;
            }
            
            // 确保索引在有效范围内
            return Math.max(0, Math.min(closestIndex, currentFlowchartData[nodeType + "Steps"].length - 1));
        }
        
        // 移动节点
        function moveNode(nodeType, fromIndex, toIndex) {
            const steps = currentFlowchartData[nodeType + "Steps"];
            
            // 移动数组元素
            const [movedItem] = steps.splice(fromIndex, 1);
            steps.splice(toIndex, 0, movedItem);
            
            // 更新流程图而不重新初始化拖拽事件
            updateFlowchartWithoutReinitialize(nodeType);
        }
        
        // 更新流程图而不重新初始化拖拽事件
        function updateFlowchartWithoutReinitialize(updatedFlowType) {
            // 保存当前编辑状态
            const wasInEditMode = editModeActive;
            
            // 更新流程图内容
            const { forwardSteps, exceptionSteps, reverseSteps } = currentFlowchartData;
            
            // 只更新修改过的流程类型，避免不必要的DOM操作
            if (updatedFlowType === "forward") {
                updateForwardFlow(forwardSteps);
            } else if (updatedFlowType === "exception") {
                updateExceptionFlow(exceptionSteps);
            } else if (updatedFlowType === "reverse") {
                updateReverseFlow(reverseSteps);
            }
            
            // 更新后重新绑定拖拽事件到新节点
            refreshDragEvents();
        }
        
        // 更新正向流程
        function updateForwardFlow(forwardSteps) {
            const forwardContainer = document.querySelector(".main-flow[data-flow-type='forward']");
            if (!forwardContainer) return;
            
            let flowHTML = "";
            let stepClass = getStepClassByFunctionId(currentFunctionId);
            
            for (let i = 0; i < forwardSteps.length; i++) {
                flowHTML += `<div class="flowchart-step ${stepClass}" data-type="forward" data-index="${i}" data-description="步骤 ${i+1}: ${forwardSteps[i]}" draggable="${editModeActive}" onclick="handleNodeClick(this)">${forwardSteps[i]}</div>`;
                
                if (i < forwardSteps.length - 1) {
                    flowHTML += `<div class="flowchart-arrow">→</div>`;
                }
            }
            
            forwardContainer.innerHTML = flowHTML;
            
            // 如果在编辑模式，为节点添加删除按钮
            if (editModeActive) {
                const nodes = forwardContainer.querySelectorAll(".flowchart-step");
                nodes.forEach(node => {
                    node.classList.add("editable");
                    addDeleteButton(node);
                });
            }
        }
        
        // 更新异常流程
        function updateExceptionFlow(exceptionSteps) {
            const exceptionContainer = document.querySelector(".main-flow[data-flow-type='exception']");
            if (!exceptionContainer || !exceptionSteps || exceptionSteps.length === 0) return;
            
            let flowHTML = "";
            
            for (let i = 0; i < exceptionSteps.length; i++) {
                flowHTML += `<div class="flowchart-step exception-step" data-type="exception" data-index="${i}" data-description="异常处理 ${i+1}: ${exceptionSteps[i]}" draggable="${editModeActive}" onclick="handleNodeClick(this)">${exceptionSteps[i]}</div>`;
                
                if (i < exceptionSteps.length - 1) {
                    flowHTML += `<div class="flowchart-arrow exception-arrow">→</div>`;
                }
            }
            
            exceptionContainer.innerHTML = flowHTML;
            
            // 如果在编辑模式，为节点添加删除按钮
            if (editModeActive) {
                const nodes = exceptionContainer.querySelectorAll(".flowchart-step");
                nodes.forEach(node => {
                    node.classList.add("editable");
                    addDeleteButton(node);
                });
            }
        }
        
        // 更新逆向流程
        function updateReverseFlow(reverseSteps) {
            const reverseContainer = document.querySelector(".main-flow[data-flow-type='reverse']");
            if (!reverseContainer || !reverseSteps || reverseSteps.length === 0) return;
            
            let flowHTML = "";
            let stepClass = getStepClassByFunctionId(currentFunctionId);
            
            for (let i = 0; i < reverseSteps.length; i++) {
                flowHTML += `<div class="flowchart-step reverse-step ${stepClass}" data-type="reverse" data-index="${i}" data-description="逆向处理 ${i+1}: ${reverseSteps[i]}" draggable="${editModeActive}" onclick="handleNodeClick(this)">${reverseSteps[i]}</div>`;
                
                if (i < reverseSteps.length - 1) {
                    flowHTML += `<div class="flowchart-arrow flowchart-reverse-arrow">→</div>`;
                }
            }
            
            reverseContainer.innerHTML = flowHTML;
            
            // 如果在编辑模式，为节点添加删除按钮
            if (editModeActive) {
                const nodes = reverseContainer.querySelectorAll(".flowchart-step");
                nodes.forEach(node => {
                    node.classList.add("editable");
                    addDeleteButton(node);
                });
            }
        }
        
        // 根据功能ID获取样式类
        function getStepClassByFunctionId(functionId) {
            if (functionId.startsWith("rfid-") || functionId.startsWith("sample-") || 
                functionId.startsWith("batch-") || functionId.startsWith("data-summary")) {
                return "flowchart-step-1";
            } else if (functionId.startsWith("checkout-") || functionId.startsWith("return-")) {
                return "flowchart-step-2";
            } else if (functionId.startsWith("inventory-")) {
                return "flowchart-step-3";
            } else {
                return "flowchart-step-4";
            }
        }
        
        // 刷新拖拽事件
        function refreshDragEvents() {
            // 只更新拖拽事件，不移除已有事件
            const flowNodes = document.querySelectorAll(".flowchart-step.editable:not(.dragging)");
            const flowContainers = document.querySelectorAll(".main-flow");
            
            // 为新节点添加拖拽事件
            flowNodes.forEach(node => {
                // 防止重复添加事件
                node.removeEventListener("dragstart", handleDragStart);
                node.removeEventListener("dragend", handleDragEnd);
                
                node.addEventListener("dragstart", handleDragStart);
                node.addEventListener("dragend", handleDragEnd);
            });
            
            // 为容器添加事件
            flowContainers.forEach(container => {
                // 防止重复添加事件
                container.removeEventListener("dragover", handleDragOver);
                container.removeEventListener("dragenter", handleDragEnter);
                container.removeEventListener("dragleave", handleDragLeave);
                container.removeEventListener("drop", handleDrop);
                
                container.addEventListener("dragover", handleDragOver);
                container.addEventListener("dragenter", handleDragEnter);
                container.addEventListener("dragleave", handleDragLeave);
                container.addEventListener("drop", handleDrop);
            });
        }
    </script>
</body>
</html> 